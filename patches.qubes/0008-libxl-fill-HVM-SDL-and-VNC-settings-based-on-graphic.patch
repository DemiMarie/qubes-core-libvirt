From a00c9836eee65653bec1e68ced1b587ec8942320 Mon Sep 17 00:00:00 2001
From: Marek Marczykowski <marmarek@invisiblethingslab.com>
Date: Sun, 7 Apr 2013 19:48:03 +0200
Subject: [PATCH 08/15] libxl: fill HVM SDL and VNC settings based on
 <graphics/> entries
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Organization: Invisible Things Lab
Cc: Marek Marczykowski-Górecki <marmarek@invisiblethingslab.com>

Vfb entries in domain config are used only by PV drivers. Qemu
parameters are build based on b_info struct. So fill it with the same
data as vfb entries (actually the first one).
This will additionally allow graphic-less domain, when no <graphics/>
entries are present in domain XML (previously VNC was always enabled).

Signed-off-by: Marek Marczykowski-Górecki <marmarek@invisiblethingslab.com>
---
 src/libxl/libxl_conf.c | 114 +++++++++++++++++++++++++++++++++++--------------
 1 file changed, 82 insertions(+), 32 deletions(-)

diff --git a/src/libxl/libxl_conf.c b/src/libxl/libxl_conf.c
index 5718241..ada9ada 100644
--- a/src/libxl/libxl_conf.c
+++ b/src/libxl/libxl_conf.c
@@ -331,7 +331,56 @@ error:
 }
 
 static int
-libxlMakeDomBuildInfo(virDomainObjPtr vm, libxl_domain_config *d_config)
+libxlMakeVNCInfo(libxlDriverPrivatePtr driver,
+                 virDomainGraphicsDefPtr l_vfb,
+                 libxl_vnc_info *x_vnc)
+{
+    unsigned short port;
+    const char *listenAddr;
+
+    libxl_defbool_set(&x_vnc->enable, 1);
+    /* driver handles selection of free port */
+    libxl_defbool_set(&x_vnc->findunused, 0);
+    if (l_vfb->data.vnc.autoport) {
+
+        if (virPortAllocatorAcquire(driver->reservedVNCPorts, &port) < 0)
+            return -1;
+        if (port == 0) {
+            virReportError(VIR_ERR_INTERNAL_ERROR,
+                    "%s", _("Unable to find an unused VNC port"));
+            return -1;
+        }
+        l_vfb->data.vnc.port = port;
+    }
+    x_vnc->display = l_vfb->data.vnc.port - LIBXL_VNC_PORT_MIN;
+
+    listenAddr = virDomainGraphicsListenGetAddress(l_vfb, 0);
+    if (listenAddr) {
+        /* libxl_device_vfb_init() does strdup("127.0.0.1") */
+        VIR_FREE(x_vnc->listen);
+        if (VIR_STRDUP(x_vnc->listen, listenAddr) < 0) {
+            return -1;
+        }
+    }
+    return 0;
+}
+
+static int
+libxlMakeSDLInfo(virDomainGraphicsDefPtr l_vfb,
+                 libxl_sdl_info *x_sdl)
+{
+    libxl_defbool_set(&x_sdl->enable, 1);
+    if (VIR_STRDUP(x_sdl->display, l_vfb->data.sdl.display) < 0)
+        return -1;
+    if (VIR_STRDUP(x_sdl->xauthority, l_vfb->data.sdl.xauth) < 0)
+        return -1;
+    return 0;
+}
+
+static int
+libxlMakeDomBuildInfo(libxlDriverPrivatePtr driver,
+                      virDomainObjPtr vm,
+                      libxl_domain_config *d_config)
 {
     virDomainDefPtr def = vm->def;
     libxlDomainObjPrivatePtr priv = vm->privateData;
@@ -411,6 +460,34 @@ libxlMakeDomBuildInfo(virDomainObjPtr vm, libxl_domain_config *d_config)
         if (VIR_STRDUP(b_info->u.hvm.boot, bootorder) < 0)
             goto error;
 
+        /* Disable VNC and SDL until explicitly enabled */
+        libxl_defbool_set(&b_info->u.hvm.vnc.enable, 0);
+        libxl_defbool_set(&b_info->u.hvm.sdl.enable, 0);
+
+        for (i = 0; i < def->ngraphics; i++) {
+            switch (def->graphics[i]->type) {
+                case VIR_DOMAIN_GRAPHICS_TYPE_VNC:
+                    if (libxl_defbool_val(b_info->u.hvm.vnc.enable))
+                        continue;
+                    if (libxlMakeVNCInfo(driver, def->graphics[i],
+                                &b_info->u.hvm.vnc) < 0)
+                        goto error;
+                    if (def->graphics[i]->data.vnc.keymap &&
+                            (b_info->u.hvm.keymap =
+                             strdup(def->graphics[i]->data.vnc.keymap)) == NULL) {
+                        virReportOOMError();
+                        goto error;
+                    }
+                    break;
+                case VIR_DOMAIN_GRAPHICS_TYPE_SDL:
+                    if (libxl_defbool_val(b_info->u.hvm.sdl.enable))
+                        continue;
+                    if (libxlMakeSDLInfo(def->graphics[i], &b_info->u.hvm.sdl) < 0)
+                        goto error;
+                    break;
+            }
+        }
+
         /*
          * The following comment and calculation were taken directly from
          * libxenlight's internal function libxl_get_required_shadow_memory():
@@ -743,43 +820,16 @@ libxlMakeVfb(libxlDriverPrivatePtr driver,
              virDomainGraphicsDefPtr l_vfb,
              libxl_device_vfb *x_vfb)
 {
-    unsigned short port;
-    const char *listenAddr;
-
     libxl_device_vfb_init(x_vfb);
 
     switch (l_vfb->type) {
         case VIR_DOMAIN_GRAPHICS_TYPE_SDL:
-            libxl_defbool_set(&x_vfb->sdl.enable, 1);
-            if (VIR_STRDUP(x_vfb->sdl.display, l_vfb->data.sdl.display) < 0)
-                return -1;
-            if (VIR_STRDUP(x_vfb->sdl.xauthority, l_vfb->data.sdl.xauth) < 0)
+            if (libxlMakeSDLInfo(l_vfb, &x_vfb->sdl) < 0)
                 return -1;
             break;
         case  VIR_DOMAIN_GRAPHICS_TYPE_VNC:
-            libxl_defbool_set(&x_vfb->vnc.enable, 1);
-            /* driver handles selection of free port */
-            libxl_defbool_set(&x_vfb->vnc.findunused, 0);
-            if (l_vfb->data.vnc.autoport) {
-
-                if (virPortAllocatorAcquire(driver->reservedVNCPorts, &port) < 0)
-                    return -1;
-                if (port == 0) {
-                    virReportError(VIR_ERR_INTERNAL_ERROR,
-                                   "%s", _("Unable to find an unused VNC port"));
-                    return -1;
-                }
-                l_vfb->data.vnc.port = port;
-            }
-            x_vfb->vnc.display = l_vfb->data.vnc.port - LIBXL_VNC_PORT_MIN;
-
-            listenAddr = virDomainGraphicsListenGetAddress(l_vfb, 0);
-            if (listenAddr) {
-                /* libxl_device_vfb_init() does VIR_STRDUP("127.0.0.1") */
-                VIR_FREE(x_vfb->vnc.listen);
-                if (VIR_STRDUP(x_vfb->vnc.listen, listenAddr) < 0)
-                    return -1;
-            }
+            if (libxlMakeVNCInfo(driver, l_vfb, &x_vfb->vnc) < 0)
+                return -1;
             if (VIR_STRDUP(x_vfb->keymap, l_vfb->data.vnc.keymap) < 0)
                 return -1;
             break;
@@ -945,7 +995,7 @@ libxlBuildDomainConfig(libxlDriverPrivatePtr driver,
     if (libxlMakeDomCreateInfo(driver, def, &d_config->c_info) < 0)
         return -1;
 
-    if (libxlMakeDomBuildInfo(vm, d_config) < 0) {
+    if (libxlMakeDomBuildInfo(driver, vm, d_config) < 0) {
         return -1;
     }
 
-- 
1.8.1.4

